<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brick-by-Brick Parser</title>
    <style>
        :root {
            --bg-primary: #f5f5f5;
            --bg-secondary: white;
            --text-primary: #333;
            --text-secondary: #666;
            --border-color: #dee2e6;
            --shadow: 0 2px 4px rgba(0,0,0,0.1);
            --link-color: #007bff;
            --success-bg: #d4edda;
            --success-text: #155724;
            --error-bg: #f8d7da;
            --error-text: #721c24;
            --code-bg: #f8f9fa;
            --hover-bg: #e9ecef;
            --btn-primary: #007bff;
            --btn-primary-hover: #0056b3;
            --btn-secondary: #6c757d;
            --btn-secondary-hover: #5a6268;
            --btn-success: #28a745;
            --btn-success-hover: #218838;
        }
        
        body.dark-mode {
            --bg-primary: #1a1a1a;
            --bg-secondary: #2d2d2d;
            --text-primary: #e0e0e0;
            --text-secondary: #b0b0b0;
            --border-color: #404040;
            --shadow: 0 2px 8px rgba(0,0,0,0.3);
            --link-color: #4da3ff;
            --success-bg: #1e4620;
            --success-text: #6ee876;
            --error-bg: #4a1c1c;
            --error-text: #ff6b6b;
            --code-bg: #3a3a3a;
            --hover-bg: #404040;
            --btn-primary: #4da3ff;
            --btn-primary-hover: #3d93ef;
            --btn-secondary: #7c8491;
            --btn-secondary-hover: #6c7481;
            --btn-success: #3eb854;
            --btn-success-hover: #2ea843;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: var(--bg-primary);
            color: var(--text-primary);
            transition: all 0.3s ease;
        }
        
        .theme-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 50px;
            padding: 5px;
            display: flex;
            gap: 5px;
            box-shadow: var(--shadow);
        }
        
        .theme-btn {
            padding: 8px 12px;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            border-radius: 50px;
            transition: all 0.2s;
            font-size: 16px;
        }
        
        .theme-btn.active {
            background: var(--btn-primary);
            color: white;
        }
        
        .container {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 20px;
            box-shadow: var(--shadow);
            margin-bottom: 20px;
        }
        
        h1 {
            color: var(--text-primary);
            margin-top: 0;
        }
        
        h2 {
            color: var(--text-primary);
            margin-top: 30px;
        }
        
        textarea {
            width: 100%;
            min-height: 200px;
            font-family: 'Courier New', monospace;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            resize: vertical;
            background: var(--code-bg);
            color: var(--text-primary);
        }
        
        button {
            background: var(--btn-primary);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 10px;
            margin-right: 10px;
            transition: all 0.2s;
        }
        
        button:hover {
            background: var(--btn-primary-hover);
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .export-buttons {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid var(--border-color);
        }
        
        .export-btn {
            background: var(--btn-success);
        }
        
        .export-btn:hover {
            background: var(--btn-success-hover);
        }
        
        pre {
            background: var(--code-bg);
            padding: 15px;
            border-radius: 4px;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            color: var(--text-primary);
        }
        
        .output {
            margin-top: 20px;
        }
        
        .brick-item {
            background: var(--code-bg);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 10px;
        }
        
        .brick-type {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 14px;
            margin-right: 10px;
        }
        
        body.dark-mode .type-person { background: #1e3a5f; color: #4da3ff; }
        body.dark-mode .type-birth { background: #4a1c2e; color: #ff6b8a; }
        body.dark-mode .type-marriage { background: #3a1f4a; color: #b679d9; }
        body.dark-mode .type-location { background: #1e4a2e; color: #4ed97e; }
        body.dark-mode .type-other { background: #4a3a1f; color: #ffa64d; }
        
        body:not(.dark-mode) .type-person { background: #e3f2fd; color: #1976d2; }
        body:not(.dark-mode) .type-birth { background: #fce4ec; color: #c2185b; }
        body:not(.dark-mode) .type-marriage { background: #f3e5f5; color: #7b1fa2; }
        body:not(.dark-mode) .type-location { background: #e8f5e9; color: #388e3c; }
        body:not(.dark-mode) .type-other { background: #fff3e0; color: #f57c00; }
        
        .visibility {
            font-weight: bold;
            margin-right: 10px;
        }
        
        .visibility.included { color: #28a745; }
        .visibility.excluded { color: #dc3545; }
        
        .alias {
            font-family: monospace;
            background: var(--hover-bg);
            padding: 2px 4px;
            border-radius: 2px;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .stat-card {
            background: var(--code-bg);
            padding: 15px;
            border-radius: 4px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
        }
        
        .stat-card:hover {
            background: var(--hover-bg);
            transform: translateY(-2px);
            box-shadow: var(--shadow);
        }
        
        .stat-card.active {
            background: var(--btn-primary);
            color: white;
            border-color: var(--btn-primary);
        }
        
        .stat-card.active .stat-label {
            color: white;
        }
        
        .stat-number {
            font-size: 24px;
            font-weight: bold;
            color: var(--text-primary);
        }
        
        .stat-card.active .stat-number {
            color: white;
        }
        
        .stat-label {
            color: var(--text-secondary);
            font-size: 14px;
        }
        
        .error {
            background: var(--error-bg);
            color: var(--error-text);
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
        }
        
        .linkage {
            color: var(--link-color);
            text-decoration: none;
            cursor: pointer;
        }
        
        .linkage:hover {
            text-decoration: underline;
        }
        
        .autocomplete {
            position: absolute;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            box-shadow: var(--shadow);
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }
        
        .autocomplete-item {
            padding: 8px 12px;
            cursor: pointer;
            border-bottom: 1px solid var(--border-color);
            color: var(--text-primary);
        }
        
        .autocomplete-item:hover {
            background: var(--hover-bg);
        }
        
        .autocomplete-item.selected {
            background: var(--link-color);
            color: white;
        }
        
        .autocomplete-emoji {
            margin-right: 8px;
        }
        
        .autocomplete-alias {
            font-family: monospace;
            color: var(--text-secondary);
            font-size: 12px;
        }
        
        .input-wrapper {
            position: relative;
        }
        
        .config-section {
            background: var(--code-bg);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 20px;
        }
        
        .config-section h3 {
            margin-top: 0;
            color: var(--link-color);
        }
        
        .file-input-wrapper {
            display: inline-block;
            margin-right: 10px;
        }
        
        .file-input {
            display: none;
        }
        
        .file-input-label {
            display: inline-block;
            padding: 8px 16px;
            background: var(--btn-secondary);
            color: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }
        
        .file-input-label:hover {
            background: var(--btn-secondary-hover);
            transform: translateY(-1px);
        }
        
        .config-status {
            display: inline-block;
            margin-left: 10px;
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 14px;
        }
        
        .config-status.success {
            background: var(--success-bg);
            color: var(--success-text);
        }
        
        .config-status.error {
            background: var(--error-bg);
            color: var(--error-text);
        }
        
        .config-preview {
            margin-top: 10px;
            font-family: monospace;
            font-size: 12px;
            background: var(--bg-secondary);
            padding: 10px;
            border-radius: 4px;
            max-height: 150px;
            overflow-y: auto;
            white-space: pre-wrap;
            line-height: 1.4;
            border: 1px solid var(--border-color);
        }
        
        .brick-item.hidden {
            display: none;
        }
        
        .filter-bar {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .filter-emoji {
            display: inline-flex;
            align-items: center;
            padding: 6px 12px;
            border: 1px solid var(--border-color);
            border-radius: 20px;
            cursor: pointer;
            background: var(--bg-secondary);
            transition: all 0.2s;
            color: var(--text-primary);
        }
        
        .filter-emoji:hover {
            background: var(--hover-bg);
            border-color: var(--text-secondary);
        }
        
        .filter-emoji.active {
            background: var(--btn-primary);
            color: white;
            border-color: var(--btn-primary);
        }
        
        .filter-emoji .emoji {
            margin-right: 5px;
            font-size: 18px;
        }
        
        .filter-emoji .count {
            font-size: 12px;
            background: rgba(0,0,0,0.1);
            padding: 2px 6px;
            border-radius: 10px;
            margin-left: 5px;
        }
        
        .filter-emoji.active .count {
            background: rgba(255,255,255,0.3);
        }
        
        .clear-filters {
            background: var(--btn-secondary);
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .clear-filters:hover {
            background: var(--btn-secondary-hover);
        }
        
        .view-tabs {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            border-bottom: 2px solid var(--border-color);
        }
        
        .view-tab {
            padding: 10px 20px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 16px;
            color: var(--text-secondary);
            border-bottom: 3px solid transparent;
            transition: all 0.2s;
        }
        
        .view-tab:hover {
            color: var(--text-primary);
            background: transparent;
            transform: none;
            box-shadow: none;
        }
        
        .view-tab.active {
            color: var(--link-color);
            border-bottom-color: var(--link-color);
        }
        
        #graphView {
            display: none;
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
        }
        
        #graphCanvas {
            border: 1px solid var(--border-color);
            border-radius: 4px;
            width: 100%;
            height: 600px;
            cursor: move;
            background: var(--bg-primary);
        }
        
        .graph-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        
        .graph-control {
            padding: 8px 16px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: var(--bg-secondary);
            cursor: pointer;
            font-size: 14px;
            color: var(--text-primary);
            transition: all 0.2s;
        }
        
        .graph-control:hover {
            background: var(--hover-bg);
            transform: translateY(-1px);
        }
        
        .graph-control.active {
            background: var(--btn-primary);
            color: white;
            border-color: var(--btn-primary);
        }
        
        .node-info {
            position: absolute;
            background: var(--bg-secondary);
            border: 1px solid var(--text-primary);
            border-radius: 4px;
            padding: 10px;
            box-shadow: var(--shadow);
            z-index: 1000;
            display: none;
            max-width: 300px;
            color: var(--text-primary);
        }
        
        .legend {
            display: flex;
            gap: 15px;
            margin-top: 10px;
            flex-wrap: wrap;
            font-size: 14px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            color: var(--text-primary);
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid var(--text-primary);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🧱 Brick-by-Brick Parser (beta)</h1>
        <p>Parse your genealogy data using the Brick notation system.</p>
        
        <div class="config-section">
            <h3>Configuration</h3>
            <p>Upload a custom configuration file to define your own brick types:</p>
            <div class="file-input-wrapper">
                <label for="configFile" class="file-input-label">📁 Upload Config File</label>
                <input type="file" id="configFile" class="file-input" accept=".txt" onchange="loadConfigFile(event)">
            </div>
            <button onclick="resetConfig()">Reset to Default</button>
            <button onclick="showConfigFormat()">Show Config Format</button>
            <div id="configStatus"></div>
            <div id="configPreview" class="config-preview" style="display: none;"></div>
        </div>
        
        <h2>Input Data</h2>
        <div class="input-wrapper">
            <textarea id="input" placeholder="Paste your brick data here...
Example:
+|👤|<john-smith>|John Smith|My great-great grandfather
+|👶|<john-smith>|1823-03-15
+|🔔|<mary-jones><john-smith>|1845-06-20|@<st-marys-church>
+|📍|<st-marys-church>|St. Mary's Church|54.4889, -0.6098"></textarea>
            <div id="autocomplete" class="autocomplete"></div>
        </div>
        
        <button onclick="parseData()">Parse Bricks</button>
        <button onclick="loadExample()">Load Example</button>
        
        <div class="view-tabs">
            <button class="view-tab active" onclick="switchView('list')">📝 List View</button>
            <button class="view-tab" onclick="switchView('graph')">🕸️ Graph View</button>
        </div>
        
        <div id="listView">
            <div id="output" class="output"></div>
        </div>
        
        <div id="graphView" >
            <h2>Relationship Graph</h2>
            <div class="graph-controls">
                <button class="graph-control" onclick="filterGraph('all')">All Connections</button>
                <button class="graph-control" onclick="filterGraph('family')">Family Only</button>
                <button class="graph-control" onclick="filterGraph('parent-child')">Has Connections</button>
                <button class="graph-control" onclick="filterGraph('marriages')">Marriages</button>
                <button class="graph-control" onclick="filterGraph('no-children')">Leaf Nodes</button>
                <button class="graph-control" onclick="filterGraph('with-children')">Parent Nodes</button>
                <button class="graph-control" onclick="centerGraph()">Center View</button>
            </div>
            <canvas id="graphCanvas"></canvas>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #4A90E2;"></div>
                    <span>Person</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #FF6B6B;"></div>
                    <span>Birth</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #9B59B6;"></div>
                    <span>Marriage</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #2ECC71;"></div>
                    <span>Location</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #F39C12;"></div>
                    <span>Other</span>
                </div>
            </div>
            <div id="nodeInfo" class="node-info"></div>
        </div>
    </div>

    <script>
        // Default brick types and their variations
        let BRICK_TYPES = {
            '👤': { name: 'person', class: 'type-person', variations: ['person', 'p', 'P'] },
            '👶': { name: 'birth', class: 'type-birth', variations: ['birth', 'b', 'B'] },
            '🔔': { name: 'marriage', class: 'type-marriage', variations: ['marriage', 'wed', 'm'] },
            '📍': { name: 'location', class: 'type-location', variations: ['location', 'place', 'l'] },
            '📄': { name: 'document', class: 'type-other', variations: ['document', 'doc', 'd'] },
            '✏️': { name: 'note', class: 'type-other', variations: ['note', 'n'] }
        };
        
        // Store the default configuration
        const DEFAULT_BRICK_TYPES = JSON.parse(JSON.stringify(BRICK_TYPES));

        let currentBricks = []; // Store parsed bricks for export
        let autocompleteData = {
            aliases: new Set(),
            emojis: new Map()
        };
        let selectedIndex = -1;
        let activeFilters = {
            visibility: null,
            types: new Set()
        };
        
        // Graph visualization variables
        let graphNodes = [];
        let graphEdges = [];
        let graphFilter = 'all';
        let canvas, ctx;
        let viewOffset = { x: 0, y: 0 };
        let isDragging = false;
        let dragStart = { x: 0, y: 0 };
        let hoveredNode = null;

        function switchView(view) {
            document.querySelectorAll('.view-tab').forEach(tab => {
                tab.classList.toggle('active', tab.textContent.includes(view === 'list' ? 'List' : 'Graph'));
            });
            
            document.getElementById('listView').style.display = view === 'list' ? 'block' : 'none';
            document.getElementById('graphView').style.display = view === 'graph' ? 'none' : 'none';
            
            if (view === 'graph') {
                initializeGraph();
            }
        }

        function initializeGraph() {
            canvas = document.getElementById('graphCanvas');
            ctx = canvas.getContext('2d');
            
            // Set canvas size
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            // Build graph data
            buildGraphData();
            
            // Position nodes using force-directed layout
            positionNodes();
            
            // Draw graph
            drawGraph();
            
            // Add event listeners
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('wheel', handleWheel);
        }

        function buildGraphData() {
            graphNodes = [];
            graphEdges = [];
            
            // Create nodes from bricks
            currentBricks.forEach((brick, index) => {
                const node = {
                    id: index,
                    brick: brick,
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    vx: 0,
                    vy: 0,
                    color: getNodeColor(brick.type),
                    radius: 20,
                    label: brick.aliases[0] || brick.shorthand,
                    connections: []
                };
                graphNodes.push(node);
            });
            
            // Create edges from linkages
            currentBricks.forEach((brick, fromIndex) => {
                brick.linkages.forEach(linkage => {
                    let toIndex = -1;
                    
                    if (linkage.startsWith('@<')) {
                        // Find node with matching alias
                        const targetAlias = linkage.slice(2, -1);
                        toIndex = currentBricks.findIndex(b => 
                            b.aliases.includes(targetAlias)
                        );
                    } else if (linkage.startsWith('@')) {
                        // Line number reference
                        const lineNum = parseInt(linkage.slice(1));
                        toIndex = currentBricks.findIndex(b => b.lineNumber === lineNum);
                    }
                    
                    if (toIndex >= 0 && toIndex !== fromIndex) {
                        graphEdges.push({
                            from: fromIndex,
                            to: toIndex,
                            type: brick.type
                        });
                        graphNodes[fromIndex].connections.push(toIndex);
                        graphNodes[toIndex].connections.push(fromIndex);
                    }
                });
            });
            
            // Identify family relationships
            identifyFamilyRelationships();
        }

        function identifyFamilyRelationships() {
            graphNodes.forEach(node => {
                node.hasChildNodes = false;
                node.hasParentNodes = false;
                node.parents = [];
                node.children = [];
                node.spouse = null;
                
                // Count incoming and outgoing connections
                node.incomingConnections = 0;
                node.outgoingConnections = 0;
                
                // Find marriages
                if (node.brick.type === 'marriage' && node.brick.aliases.length >= 2) {
                    const spouse1 = graphNodes.find(n => n.brick.aliases.includes(node.brick.aliases[0]));
                    const spouse2 = graphNodes.find(n => n.brick.aliases.includes(node.brick.aliases[1]));
                    if (spouse1 && spouse2) {
                        spouse1.spouse = spouse2.id;
                        spouse2.spouse = spouse1.id;
                    }
                }
            });
            
            // Analyze graph structure
            graphEdges.forEach(edge => {
                graphNodes[edge.from].outgoingConnections++;
                graphNodes[edge.to].incomingConnections++;
                graphNodes[edge.from].hasChildNodes = true;
                graphNodes[edge.to].hasParentNodes = true;
            });
        }

        function getNodeColor(type) {
            const colors = {
                'person': '#4A90E2',
                'birth': '#FF6B6B',
                'marriage': '#9B59B6',
                'location': '#2ECC71',
                'document': '#F39C12',
                'note': '#E67E22',
                'other': '#95A5A6'
            };
            return colors[type] || colors['other'];
        }

        function positionNodes() {
            // Simple force-directed layout
            const iterations = 100;
            const k = Math.sqrt((canvas.width * canvas.height) / graphNodes.length) * 0.5;
            
            for (let iter = 0; iter < iterations; iter++) {
                // Repulsive forces between all nodes
                for (let i = 0; i < graphNodes.length; i++) {
                    for (let j = i + 1; j < graphNodes.length; j++) {
                        const dx = graphNodes[j].x - graphNodes[i].x;
                        const dy = graphNodes[j].y - graphNodes[i].y;
                        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                        const force = k * k / dist;
                        
                        graphNodes[i].vx -= force * dx / dist;
                        graphNodes[i].vy -= force * dy / dist;
                        graphNodes[j].vx += force * dx / dist;
                        graphNodes[j].vy += force * dy / dist;
                    }
                }
                
                // Attractive forces for connected nodes
                graphEdges.forEach(edge => {
                    const node1 = graphNodes[edge.from];
                    const node2 = graphNodes[edge.to];
                    const dx = node2.x - node1.x;
                    const dy = node2.y - node1.y;
                    const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                    const force = dist * dist / k;
                    
                    node1.vx += force * dx / dist * 0.1;
                    node1.vy += force * dy / dist * 0.1;
                    node2.vx -= force * dx / dist * 0.1;
                    node2.vy -= force * dy / dist * 0.1;
                });
                
                // Update positions
                graphNodes.forEach(node => {
                    node.x += node.vx * 0.1;
                    node.y += node.vy * 0.1;
                    node.vx *= 0.9; // damping
                    node.vy *= 0.9;
                    
                    // Keep nodes on screen
                    node.x = Math.max(50, Math.min(canvas.width - 50, node.x));
                    node.y = Math.max(50, Math.min(canvas.height - 50, node.y));
                });
            }
        }

        function drawGraph() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(viewOffset.x, viewOffset.y);
            
            // Draw edges
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 2;
            graphEdges.forEach(edge => {
                if (shouldShowEdge(edge)) {
                    const from = graphNodes[edge.from];
                    const to = graphNodes[edge.to];
                    ctx.beginPath();
                    ctx.moveTo(from.x, from.y);
                    ctx.lineTo(to.x, to.y);
                    ctx.stroke();
                }
            });
            
            // Draw nodes
            graphNodes.forEach(node => {
                if (shouldShowNode(node)) {
                    // Node circle
                    ctx.fillStyle = node.color;
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Node label
                    ctx.fillStyle = '#333';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(node.label, node.x, node.y + node.radius + 15);
                }
            });
            
            ctx.restore();
        }

        function shouldShowNode(node) {
            if (graphFilter === 'all') return true;
            if (graphFilter === 'family' && node.brick.type === 'person') return true;
            if (graphFilter === 'marriages' && (node.brick.type === 'marriage' || node.spouse !== null)) return true;
            if (graphFilter === 'no-children' && !node.hasChildNodes) return true;
            if (graphFilter === 'with-children' && node.hasChildNodes) return true;
            if (graphFilter === 'parent-child' && (node.hasParentNodes || node.hasChildNodes)) return true;
            return false;
        }

        function shouldShowEdge(edge) {
            return shouldShowNode(graphNodes[edge.from]) && shouldShowNode(graphNodes[edge.to]);
        }

        function filterGraph(filter) {
            graphFilter = filter;
            document.querySelectorAll('.graph-control').forEach(btn => {
                btn.classList.toggle('active', btn.onclick.toString().includes(`'${filter}'`));
            });
            drawGraph();
        }

        function centerGraph() {
            viewOffset = { x: 0, y: 0 };
            drawGraph();
        }

        function handleMouseDown(e) {
            isDragging = true;
            dragStart = { x: e.clientX - viewOffset.x, y: e.clientY - viewOffset.y };
        }

        function handleMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left - viewOffset.x;
            const y = e.clientY - rect.top - viewOffset.y;
            
            if (isDragging) {
                viewOffset.x = e.clientX - dragStart.x;
                viewOffset.y = e.clientY - dragStart.y;
                drawGraph();
            } else {
                // Check for hover
                let newHoveredNode = null;
                graphNodes.forEach(node => {
                    const dist = Math.sqrt((x - node.x) ** 2 + (y - node.y) ** 2);
                    if (dist < node.radius && shouldShowNode(node)) {
                        newHoveredNode = node;
                    }
                });
                
                if (newHoveredNode !== hoveredNode) {
                    hoveredNode = newHoveredNode;
                    if (hoveredNode) {
                        showNodeInfo(hoveredNode, e.clientX, e.clientY);
                    } else {
                        hideNodeInfo();
                    }
                }
            }
        }

        function handleMouseUp() {
            isDragging = false;
        }

        function handleWheel(e) {
            e.preventDefault();
            // Simple zoom could be added here
        }

        function showNodeInfo(node, x, y) {
            const info = document.getElementById('nodeInfo');
            let html = `<strong>${node.brick.type}</strong><br>`;
            if (node.brick.aliases.length > 0) {
                html += `Alias: ${node.brick.aliases.join(', ')}<br>`;
            }
            if (node.brick.data.length > 0) {
                html += `Data: ${node.brick.data.join(' | ')}<br>`;
            }
            html += `Total Connections: ${node.connections.length}<br>`;
            html += `Outgoing: ${node.outgoingConnections} | Incoming: ${node.incomingConnections}`;
            
            info.innerHTML = html;
            info.style.display = 'block';
            info.style.left = x + 10 + 'px';
            info.style.top = y + 10 + 'px';
        }

        function hideNodeInfo() {
            document.getElementById('nodeInfo').style.display = 'none';
        }

        function parseConfigFile(content) {
            const lines = content.split('\n');
            const newBrickTypes = {};
            const errors = [];
            
            lines.forEach((line, index) => {
                line = line.trim();
                // Skip empty lines and comments
                if (!line || line.startsWith('#')) return;
                
                // Parse config line format: [+,-]|[👤,person,p,P]|[alias]|[text]|[text]|[linkage]
                const parts = line.split('|').map(p => p.trim());
                if (parts.length < 2) return;
                
                // Extract variations from second part [emoji,var1,var2,...]
                const variationMatch = parts[1].match(/\[([^\]]+)\]/);
                if (!variationMatch) {
                    errors.push(`Line ${index + 1}: Invalid format - expected [emoji,variations]`);
                    return;
                }
                
                const variations = variationMatch[1].split(',').map(v => v.trim());
                if (variations.length === 0) return;
                
                const emoji = variations[0];
                const varNames = variations.slice(1);
                
                // Determine the type name and class
                let typeName = varNames[0] || 'custom';
                let typeClass = 'type-other';
                
                // Map common types to specific classes
                if (typeName.toLowerCase().includes('person')) typeClass = 'type-person';
                else if (typeName.toLowerCase().includes('birth')) typeClass = 'type-birth';
                else if (typeName.toLowerCase().includes('marriage') || typeName.toLowerCase().includes('wed')) typeClass = 'type-marriage';
                else if (typeName.toLowerCase().includes('location') || typeName.toLowerCase().includes('place')) typeClass = 'type-location';
                
                newBrickTypes[emoji] = {
                    name: typeName.toLowerCase(),
                    class: typeClass,
                    variations: varNames.map(v => v.toLowerCase())
                };
            });
            
            if (Object.keys(newBrickTypes).length > 0) {
                BRICK_TYPES = newBrickTypes;
                return { success: true, types: newBrickTypes, errors };
            } else {
                return { success: false, errors: errors.length > 0 ? errors : ['No valid brick definitions found'] };
            }
        }

        function toggleFilter(filterType, value) {
            if (filterType === 'visibility') {
                if (activeFilters.visibility === value) {
                    activeFilters.visibility = null;
                } else {
                    activeFilters.visibility = value;
                }
            } else if (filterType === 'type') {
                if (activeFilters.types.has(value)) {
                    activeFilters.types.delete(value);
                } else {
                    activeFilters.types.add(value);
                }
            }
            applyFilters();
        }

        function clearFilters() {
            activeFilters.visibility = null;
            activeFilters.types.clear();
            applyFilters();
        }

        function applyFilters() {
            // Update stat card styles
            document.querySelectorAll('.stat-card').forEach(card => {
                const filterValue = card.dataset.filter;
                const filterType = card.dataset.filterType;
                
                if (filterType === 'visibility') {
                    card.classList.toggle('active', activeFilters.visibility === filterValue);
                } else if (filterType === 'type') {
                    card.classList.toggle('active', activeFilters.types.has(filterValue));
                }
            });
            
            // Update emoji filter styles
            document.querySelectorAll('.filter-emoji').forEach(filter => {
                const emoji = filter.dataset.emoji;
                filter.classList.toggle('active', activeFilters.types.has(emoji));
            });
            
            // Filter brick items
            document.querySelectorAll('.brick-item').forEach(item => {
                const visibility = item.dataset.visibility;
                const type = item.dataset.type;
                const emoji = item.dataset.emoji;
                
                let show = true;
                
                // Check visibility filter
                if (activeFilters.visibility && visibility !== activeFilters.visibility) {
                    show = false;
                }
                
                // Check type filter
                if (activeFilters.types.size > 0 && !activeFilters.types.has(type) && !activeFilters.types.has(emoji)) {
                    show = false;
                }
                
                item.classList.toggle('hidden', !show);
            });
        }

        function loadConfigFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const content = e.target.result;
                const result = parseConfigFile(content);
                
                const statusDiv = document.getElementById('configStatus');
                const previewDiv = document.getElementById('configPreview');
                
                if (result.success) {
                    statusDiv.innerHTML = '<span class="config-status success">✓ Config loaded successfully</span>';
                    
                    // Show preview of loaded types
                    let preview = 'Loaded brick types:\n\n';
                    Object.entries(result.types).forEach(([emoji, type]) => {
                        preview += `${emoji} → ${type.name} (${type.variations.join(', ')})\n`;
                    });
                    previewDiv.textContent = preview;
                    previewDiv.style.display = 'block';
                    
                    // Re-parse data with new config
                    parseData();
                } else {
                    statusDiv.innerHTML = '<span class="config-status error">✗ ' + result.errors.join('; ') + '</span>';
                    previewDiv.style.display = 'none';
                }
            };
            reader.readAsText(file);
        }

        function resetConfig() {
            BRICK_TYPES = JSON.parse(JSON.stringify(DEFAULT_BRICK_TYPES));
            document.getElementById('configStatus').innerHTML = '<span class="config-status success">✓ Reset to default configuration</span>';
            document.getElementById('configPreview').style.display = 'none';
            document.getElementById('configFile').value = '';
            parseData();
        }

        function showConfigFormat() {
            const previewDiv = document.getElementById('configPreview');
            const example = `# Example configuration file format:
# [visibility]|[shorthand]|[datetime]|[alias]|[text]|[linkage]

# Person brick
[+,-]|[👤,person,p,P]|[alias]|[text]|[text]|[linkage]

# Birth brick  
[+,-]|[👶,birth,b,B]|[alias]|[date]||[linkage]

# Marriage brick
[+,-]|[🔔,marriage,wed,m]|[alias+alias]|[date]||[linkage]

# Location brick
[+,-]|[📍,location,place,l]|[alias]|[text]|[linkage]

# Custom bricks
[+,-]|[💼,occupation,job,o]|[alias]|[text]|[date]|[linkage]
[+,-]|[⚰️,death,d,D]|[alias]|[date]|[text]|[linkage]
[+,-]|[🏠,residence,home,h]|[alias]|[text]|[date]|[linkage]
[+,-]|[📚,education,school,e]|[alias]|[text]|[date]|[linkage]`;
            
            previewDiv.textContent = example;
            previewDiv.style.display = 'block';
        }

        function updateAutocompleteData() {
            // Clear existing data
            autocompleteData.aliases.clear();
            autocompleteData.emojis.clear();
            
            // Collect all aliases and emojis from current input
            const input = document.getElementById('input').value;
            const lines = input.split('\n');
            
            lines.forEach(line => {
                line = line.trim();
                if (!line || line.startsWith('#')) return;
                
                const parts = line.split('|').map(p => p.trim());
                if (parts.length < 3) return;
                
                // Collect aliases
                const aliasMatches = parts[2].match(/<[^>]+>/g);
                if (aliasMatches) {
                    aliasMatches.forEach(alias => {
                        autocompleteData.aliases.add(alias.slice(1, -1));
                    });
                }
                
                // Collect emoji usage
                const emoji = parts[1];
                if (emoji && emoji.match(/[\u{1F300}-\u{1F9FF}]/u)) {
                    if (!autocompleteData.emojis.has(emoji)) {
                        autocompleteData.emojis.set(emoji, []);
                    }
                    // Store the line for context
                    autocompleteData.emojis.get(emoji).push(parts.slice(2).join('|'));
                }
            });
        }

        function showAutocomplete(items, type) {
            const autocomplete = document.getElementById('autocomplete');
            const input = document.getElementById('input');
            
            if (items.length === 0) {
                autocomplete.style.display = 'none';
                return;
            }
            
            // Position autocomplete
            const inputRect = input.getBoundingClientRect();
            const cursorPos = input.selectionStart;
            const textBeforeCursor = input.value.substring(0, cursorPos);
            const lines = textBeforeCursor.split('\n');
            const currentLine = lines.length;
            
            // Rough estimate of cursor position
            autocomplete.style.top = `${(currentLine * 20) + 30}px`;
            autocomplete.style.left = '10px';
            
            // Build autocomplete content
            let html = '';
            items.forEach((item, index) => {
                if (type === 'alias') {
                    html += `<div class="autocomplete-item ${index === selectedIndex ? 'selected' : ''}" data-value="<${item}>" data-index="${index}">
                               <span class="autocomplete-alias">&lt;${item}&gt;</span>
                             </div>`;
                } else if (type === 'emoji') {
                    const examples = autocompleteData.emojis.get(item);
                    const example = examples[0].split('|')[0] || '';
                    html += `<div class="autocomplete-item ${index === selectedIndex ? 'selected' : ''}" data-value="${item}" data-index="${index}">
                               <span class="autocomplete-emoji">${item}</span>
                               <span class="autocomplete-alias">${example}</span>
                             </div>`;
                }
            });
            
            autocomplete.innerHTML = html;
            autocomplete.style.display = 'block';
            
            // Add click handlers
            autocomplete.querySelectorAll('.autocomplete-item').forEach(item => {
                item.addEventListener('click', function() {
                    insertAutocomplete(this.dataset.value);
                });
            });
        }

        function hideAutocomplete() {
            document.getElementById('autocomplete').style.display = 'none';
            selectedIndex = -1;
        }

        function insertAutocomplete(value) {
            const input = document.getElementById('input');
            const cursorPos = input.selectionStart;
            const text = input.value;
            
            // Find the trigger character (@ or emoji start)
            let triggerPos = cursorPos - 1;
            while (triggerPos >= 0) {
                const char = text[triggerPos];
                if (char === '@' || char === '|') {
                    break;
                }
                triggerPos--;
            }
            
            // Replace from trigger to cursor
            const before = text.substring(0, triggerPos + 1);
            const after = text.substring(cursorPos);
            input.value = before + value + after;
            
            // Set cursor position after inserted value
            const newPos = triggerPos + 1 + value.length;
            input.setSelectionRange(newPos, newPos);
            
            hideAutocomplete();
            input.focus();
        }

        // Handle input events
        document.getElementById('input').addEventListener('input', function(e) {
            updateAutocompleteData();
            
            const cursorPos = this.selectionStart;
            const text = this.value;
            const textBeforeCursor = text.substring(0, cursorPos);
            
            // Check for @ trigger
            const atMatch = textBeforeCursor.match(/@([^@\s]*)$/);
            if (atMatch) {
                const search = atMatch[1].toLowerCase();
                const matches = Array.from(autocompleteData.aliases)
                    .filter(alias => alias.toLowerCase().includes(search))
                    .slice(0, 10);
                showAutocomplete(matches, 'alias');
                return;
            }
            
            // Check for emoji trigger (after |)
            const pipeMatch = textBeforeCursor.match(/\|([^|]*)$/);
            if (pipeMatch && pipeMatch[1].length <= 2) {
                const matches = Array.from(autocompleteData.emojis.keys()).slice(0, 10);
                showAutocomplete(matches, 'emoji');
                return;
            }
            
            hideAutocomplete();
        });

        // Handle keyboard navigation
        document.getElementById('input').addEventListener('keydown', function(e) {
            const autocomplete = document.getElementById('autocomplete');
            if (autocomplete.style.display === 'none') return;
            
            const items = autocomplete.querySelectorAll('.autocomplete-item');
            
            if (e.key === 'ArrowDown') {
                e.preventDefault();
                selectedIndex = Math.min(selectedIndex + 1, items.length - 1);
                updateSelection();
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                selectedIndex = Math.max(selectedIndex - 1, -1);
                updateSelection();
            } else if (e.key === 'Enter' && selectedIndex >= 0) {
                e.preventDefault();
                insertAutocomplete(items[selectedIndex].dataset.value);
            } else if (e.key === 'Escape') {
                hideAutocomplete();
            }
        });

        function updateSelection() {
            const items = document.querySelectorAll('.autocomplete-item');
            items.forEach((item, index) => {
                item.classList.toggle('selected', index === selectedIndex);
            });
        }

        // Hide autocomplete when clicking outside
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.input-wrapper')) {
                hideAutocomplete();
            }
        });

        function parseBrick(line, lineNumber) {
            line = line.trim();
            if (!line || line.startsWith('#')) return null;
            
            const parts = line.split('|').map(p => p.trim());
            if (parts.length < 3) return null;
            
            const brick = {
                lineNumber: lineNumber,
                visibility: parts[0],
                shorthand: parts[1],
                alias: parts[2],
                data: parts.slice(3),
                raw: line
            };
            
            // Determine brick type
            const typeInfo = BRICK_TYPES[brick.shorthand] || 
                           Object.values(BRICK_TYPES).find(t => 
                               t.variations.includes(brick.shorthand.toLowerCase())
                           );
            
            if (typeInfo) {
                brick.type = typeInfo.name;
                brick.typeClass = typeInfo.class;
            } else {
                brick.type = 'other';
                brick.typeClass = 'type-other';
            }
            
            // Parse aliases (can be multiple for marriages)
            const aliasMatches = brick.alias.match(/<[^>]+>/g);
            brick.aliases = aliasMatches ? aliasMatches.map(a => a.slice(1, -1)) : [];
            
            // Parse linkages - look through ALL parts for @ references
            brick.linkages = [];
            
            // Check alias field for linkages (like @<tag>)
            const aliasLinkMatches = brick.alias.match(/@<[^>]+>|@\d+/g);
            if (aliasLinkMatches) {
                brick.linkages.push(...aliasLinkMatches);
            }
            
            // Check all data fields for linkages
            parts.slice(3).forEach(part => {
                // Match @<alias>, @number, @number:number, @number,number
                const linkMatches = part.match(/@<[^>]+>|@\d+(?::\d+)?|@\d+(?:,\d+)*/g);
                if (linkMatches) {
                    brick.linkages.push(...linkMatches);
                }
            });
            
            // Remove duplicates
            brick.linkages = [...new Set(brick.linkages)];
            
            return brick;
        }

        function parseData() {
            const input = document.getElementById('input').value;
            const lines = input.split('\n');
            const bricks = [];
            const errors = [];
            
            lines.forEach((line, index) => {
                try {
                    const brick = parseBrick(line, index + 1);
                    if (brick) {
                        bricks.push(brick);
                    }
                } catch (e) {
                    errors.push(`Line ${index + 1}: ${e.message}`);
                }
            });
            
            currentBricks = bricks; // Store for export
            updateAutocompleteData(); // Update autocomplete data
            displayResults(bricks, errors);
        }

        function displayResults(bricks, errors) {
            const output = document.getElementById('output');
            let html = '';
            
            // Display errors if any
            if (errors.length > 0) {
                html += '<div class="error">';
                html += '<strong>Parsing Errors:</strong><br>';
                html += errors.join('<br>');
                html += '</div>';
            }
            
            // Statistics
            const stats = calculateStats(bricks);
            html += '<h2>Statistics</h2>';
            html += '<div class="stats">';
            html += `<div class="stat-card" data-filter-type="none">
                        <div class="stat-number">${stats.total}</div>
                        <div class="stat-label">Total Bricks</div>
                     </div>`;
            html += `<div class="stat-card" onclick="toggleFilter('visibility', '+')" data-filter="+" data-filter-type="visibility">
                        <div class="stat-number">${stats.included}</div>
                        <div class="stat-label">Included (+)</div>
                     </div>`;
            html += `<div class="stat-card" onclick="toggleFilter('visibility', '-')" data-filter="-" data-filter-type="visibility">
                        <div class="stat-number">${stats.excluded}</div>
                        <div class="stat-label">Excluded (-)</div>
                     </div>`;
            
            Object.entries(stats.byType).forEach(([type, count]) => {
                if (count > 0) {
                    html += `<div class="stat-card" onclick="toggleFilter('type', '${type}')" data-filter="${type}" data-filter-type="type">
                                <div class="stat-number">${count}</div>
                                <div class="stat-label">${type}</div>
                             </div>`;
                }
            });
            html += '</div>';
            
            // Export buttons
            if (bricks.length > 0) {
                html += '<div class="export-buttons">';
                html += '<h2>Export Data</h2>';
                html += '<button class="export-btn" onclick="exportJSON()">Export as JSON</button>';
                html += '<button class="export-btn" onclick="exportCSV()">Export as CSV</button>';
                html += '<button class="export-btn" onclick="showJSON()">Show JSON</button>';
                html += '<button class="export-btn" onclick="showCSV()">Show CSV</button>';
                html += '<div id="export-preview"></div>';
                html += '</div>';
            }
            
            // Parsed bricks with filter bar
            html += '<h2>Parsed Bricks</h2>';
            
            // Create emoji filter bar
            const emojiStats = {};
            bricks.forEach(brick => {
                if (!emojiStats[brick.shorthand]) {
                    emojiStats[brick.shorthand] = { count: 0, type: brick.type };
                }
                emojiStats[brick.shorthand].count++;
            });
            
            html += '<div class="filter-bar">';
            Object.entries(emojiStats).forEach(([emoji, data]) => {
                html += `<div class="filter-emoji" onclick="toggleFilter('type', '${emoji}')" data-emoji="${emoji}">
                            <span class="emoji">${emoji}</span>
                            <span>${data.type}</span>
                            <span class="count">${data.count}</span>
                         </div>`;
            });
            if (Object.keys(emojiStats).length > 0) {
                html += '<button class="clear-filters" onclick="clearFilters()">Clear Filters</button>';
            }
            html += '</div>';
            
            // Brick items
            bricks.forEach(brick => {
                html += `<div class="brick-item" data-visibility="${brick.visibility}" data-type="${brick.type}" data-emoji="${brick.shorthand}">`;
                html += `<span class="visibility ${brick.visibility === '+' ? 'included' : 'excluded'}">${brick.visibility}</span>`;
                html += `<span class="brick-type ${brick.typeClass}">${brick.shorthand} ${brick.type}</span>`;
                
                if (brick.aliases.length > 0) {
                    html += 'Alias: ';
                    brick.aliases.forEach(alias => {
                        html += `<span class="alias">${alias}</span> `;
                    });
                }
                
                if (brick.data.length > 0) {
                    html += '<br>Data: ' + brick.data.map(d => {
                        // Highlight linkages in data fields
                        return d.replace(/@<[^>]+>|@\d+(?::\d+)?|@\d+(?:,\d+)*/g, match => 
                            `<span class="linkage">${match}</span>`
                        );
                    }).join(' | ');
                }
                
                if (brick.linkages.length > 0) {
                    html += '<br>Links: ';
                    brick.linkages.forEach(link => {
                        html += `<span class="linkage">${link}</span> `;
                    });
                }
                
                html += `<br><small>Line ${brick.lineNumber}</small>`;
                html += '</div>';
            });
            
            output.innerHTML = html;
        }

        function calculateStats(bricks) {
            const stats = {
                total: bricks.length,
                included: bricks.filter(b => b.visibility === '+').length,
                excluded: bricks.filter(b => b.visibility === '-').length,
                byType: {}
            };
            
            bricks.forEach(brick => {
                stats.byType[brick.type] = (stats.byType[brick.type] || 0) + 1;
            });
            
            return stats;
        }

        function convertToJSON() {
            return currentBricks.map(brick => ({
                line: brick.lineNumber,
                visibility: brick.visibility,
                included: brick.visibility === '+',
                type: brick.type,
                shorthand: brick.shorthand,
                aliases: brick.aliases,
                alias_raw: brick.alias,
                data: brick.data,
                linkages: brick.linkages,
                raw: brick.raw
            }));
        }

        function convertToCSV() {
            if (currentBricks.length === 0) return '';
            
            // CSV headers
            const headers = ['line', 'visibility', 'included', 'type', 'shorthand', 'aliases', 'data1', 'data2', 'data3', 'linkages', 'raw'];
            let csv = headers.join(',') + '\n';
            
            // CSV rows
            currentBricks.forEach(brick => {
                const row = [
                    brick.lineNumber,
                    brick.visibility,
                    brick.visibility === '+',
                    brick.type,
                    brick.shorthand,
                    '"' + brick.aliases.join(';') + '"',
                    brick.data[0] ? '"' + (brick.data[0] || '').replace(/"/g, '""') + '"' : '',
                    brick.data[1] ? '"' + (brick.data[1] || '').replace(/"/g, '""') + '"' : '',
                    brick.data[2] ? '"' + (brick.data[2] || '').replace(/"/g, '""') + '"' : '',
                    '"' + brick.linkages.join(';') + '"',
                    '"' + brick.raw.replace(/"/g, '""') + '"'
                ];
                csv += row.join(',') + '\n';
            });
            
            return csv;
        }

        function downloadFile(content, filename, type) {
            const blob = new Blob([content], { type: type });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function exportJSON() {
            const json = JSON.stringify(convertToJSON(), null, 2);
            downloadFile(json, 'bricks-export.json', 'application/json');
        }

        function exportCSV() {
            const csv = convertToCSV();
            downloadFile(csv, 'bricks-export.csv', 'text/csv');
        }

        function showJSON() {
            const json = JSON.stringify(convertToJSON(), null, 2);
            const preview = document.getElementById('export-preview');
            preview.innerHTML = '<h3>JSON Preview</h3><pre>' + json + '</pre>';
        }

        function showCSV() {
            const csv = convertToCSV();
            const preview = document.getElementById('export-preview');
            preview.innerHTML = '<h3>CSV Preview</h3><pre>' + csv + '</pre>';
        }

        function loadExample() {
            const example = `+|👤|<john-smith>|John Smith|My great-great grandfather
+|👤|<mary-jones>|Mary Jones|Came from Ireland
+|👶|<john-smith>|1823-03-15
+|🔔|<mary-jones><john-smith>|1845-06-20|@<st-marys-church>
+|📍|<st-marys-church>|St. Mary's Church|54.4889, -0.6098
+|📍|<dundee>|Dundee|56.5, -3.0
+|📍|<longforgan>|Longforgan|56.43, -3.07
+|📄|<1891-census>|Household at @<42-dudhope-crest>|@5:17
+|✏️|1891|George|22
+|✏️|1891|Margaret|60
-|👤|<test-person>|Test Person|This is excluded`;
            
            document.getElementById('input').value = example;
            parseData();
        }
        
        // Load example on page load
        window.onload = loadExample;
    </script>
</body>
</html>